(()=>{"use strict";var e,n="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var e=new n(16);return n!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)}),e=new n(3),n!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0);var o=function(e,n,t,o){return new(t||(t=Promise))((function(r,i){function a(e){try{u(o.next(e))}catch(e){i(e)}}function s(e){try{u(o.throw(e))}catch(e){i(e)}}function u(e){var n;e.done?r(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(a,s)}u((o=o.apply(e,n||[])).next())}))};let r,i,a=null,s=null,u=null,c=null,l=null,f=null,d=null,p=null,v=null,g=null,m=null,y=null;function h(){let e="";return e+=`let kWorkgroupSize = ${i};\n`,e+=`let kNumBodies = ${r};\n`,e+"// Simulation parameters.\nlet kDelta = 0.000025;\nlet kSoftening = 0.2;\n\n[[block]]\nstruct Float4Buffer {\n  data : array<vec4<f32>>;\n};\n\n[[group(0), binding(0)]]\nvar<storage, read_write> positionsIn : Float4Buffer;\n\n[[group(0), binding(1)]]\nvar<storage, read_write> positionsOut : Float4Buffer;\n\n[[group(0), binding(2)]]\nvar<storage, read_write> velocities : Float4Buffer;\n\nfn computeForce(ipos : vec4<f32>,\n                jpos : vec4<f32>,\n                ) -> vec4<f32> {\n  let d = vec4<f32>((jpos - ipos).xyz, 0.0);\n  let distSq = d.x*d.x + d.y*d.y + d.z*d.z + kSoftening*kSoftening;\n  let dist   = inverseSqrt(distSq);\n  let coeff  = jpos.w * (dist*dist*dist);\n  return coeff * d;\n}\n\n[[stage(compute), workgroup_size(kWorkgroupSize)]]\nfn cs_main(\n  [[builtin(global_invocation_id)]] gid : vec3<u32>,\n  ) {\n  let idx = gid.x;\n  let pos = positionsIn.data[idx];\n\n  // Compute force.\n  var force = vec4<f32>(0.0);\n  for (var i = 0; i < kNumBodies; i = i + 1) {\n    force = force + computeForce(pos, positionsIn.data[i]);\n  }\n\n  // Update velocity.\n  var velocity = velocities.data[idx];\n  velocity = velocity + force * kDelta;\n  velocities.data[idx] = velocity;\n\n  // Update position.\n  positionsOut.data[idx] = pos + velocity * kDelta;\n}\n\n[[block]]\nstruct RenderParams {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[group(0), binding(0)]]\nvar<uniform> renderParams : RenderParams;\n\nstruct VertexOut {\n  [[builtin(position)]] position : vec4<f32>;\n  [[location(0)]] positionInQuad : vec2<f32>;\n  [[location(1), interpolate(flat)]] color : vec3<f32>;\n};\n\n[[stage(vertex)]]\nfn vs_main(\n  [[builtin(instance_index)]] idx : u32,\n  [[builtin(vertex_index)]] vertex : u32,\n  [[location(0)]] position : vec4<f32>,\n  ) -> VertexOut {\n\n  let kPointRadius = 0.005;\n  var vertexOffsets = array<vec2<f32>, 6>(\n    vec2<f32>(1.0, -1.0),\n    vec2<f32>(-1.0, -1.0),\n    vec2<f32>(-1.0, 1.0),\n    vec2<f32>(-1.0, 1.0),\n    vec2<f32>(1.0, 1.0),\n    vec2<f32>(1.0, -1.0),\n  );\n  let offset = vertexOffsets[vertex];\n\n  var out : VertexOut;\n  out.position = renderParams.viewProjectionMatrix *\n    vec4<f32>(position.xy + offset * kPointRadius, position.zw);\n  out.positionInQuad = offset;\n  if (idx % 2u == 0u) {\n    out.color = vec3<f32>(0.4, 0.4, 1.0);\n  } else {\n    out.color = vec3<f32>(1.0, 0.4, 0.4);\n  }\n  return out;\n}\n\n[[stage(fragment)]]\nfn fs_main(\n  [[builtin(position)]] position : vec4<f32>,\n  [[location(0)]] positionInQuad : vec2<f32>,\n  [[location(1), interpolate(flat)]] color : vec3<f32>,\n  ) -> [[location(0)]] vec4<f32> {\n  // Calculate the normalized distance from this fragment to the quad center.\n  let distFromCenter = length(positionInQuad);\n\n  // Discard fragments that are outside the circle.\n  if (distFromCenter > 1.0) {\n    discard;\n  }\n\n  let intensity = 1.0 - distFromCenter;\n  return vec4<f32>(intensity*color, 1.0);\n}\n"}let x=0,b=null;function P(){if(!u)return void requestAnimationFrame(P);if(b){const e=performance.now()-b;if(e>=500){const n=x/(e/1e3);document.getElementById("fps").innerHTML=n.toFixed(1)+" FPS",b=performance.now(),x=0}}else b=performance.now();x++;const e=a.createCommandEncoder();m=a.createBindGroup({layout:u.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:p}},{binding:2,resource:{buffer:v}}]}),y=a.createBindGroup({layout:c.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:g}}]});const n=e.beginComputePass();n.setPipeline(u),n.setBindGroup(0,m),n.dispatch(r/i),n.endPass();const t={view:f.getCurrentTexture().createView(),loadValue:{r:0,g:0,b:.1,a:1},storeOp:"store"},o=e.beginRenderPass({colorAttachments:[t]});o.setPipeline(c),o.setViewport(0,0,l.width,l.height,0,1),o.setScissorRect(0,0,l.width,l.height),o.setBindGroup(0,y),o.setVertexBuffer(0,p),o.draw(6,r),o.endPass(),s.submit([e.finish()]),[d,p]=[p,d],requestAnimationFrame(P)}const w=()=>o(void 0,void 0,void 0,(function*(){null==a&&(yield o(void 0,void 0,void 0,(function*(){const e=yield navigator.gpu.requestAdapter();a=yield e.requestDevice(),s=a.queue,l=document.getElementById("canvas"),f=l.getContext("webgpu"),f.configure({device:a,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),P()})));const e=e=>{let n=document.getElementById(e);return Number(n.selectedOptions[0].value)};r=e("numbodies"),i=e("wgsize"),function(){c=null,u=null;let e=function(e,t,o){var r=new n(3);return r[0]=0,r[1]=0,r[2]=-1.5,r}(),o=t(),i=t();!function(e,n,t,o,r){var i,a=1/Math.tan(.5);e[0]=a/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i=1/-49.9,e[10]=50*i,e[14]=5*i}(o,0,l.width/l.height),function(e,n,t){var o,r,i,a,s,u,c,l,f,d,p,v,g=t[0],m=t[1],y=t[2];n===e?(e[12]=n[0]*g+n[4]*m+n[8]*y+n[12],e[13]=n[1]*g+n[5]*m+n[9]*y+n[13],e[14]=n[2]*g+n[6]*m+n[10]*y+n[14],e[15]=n[3]*g+n[7]*m+n[11]*y+n[15]):(o=n[0],r=n[1],i=n[2],a=n[3],s=n[4],u=n[5],c=n[6],l=n[7],f=n[8],d=n[9],p=n[10],v=n[11],e[0]=o,e[1]=r,e[2]=i,e[3]=a,e[4]=s,e[5]=u,e[6]=c,e[7]=l,e[8]=f,e[9]=d,e[10]=p,e[11]=v,e[12]=o*g+s*m+f*y+n[12],e[13]=r*g+u*m+d*y+n[13],e[14]=i*g+c*m+p*y+n[14],e[15]=a*g+l*m+v*y+n[15])}(i,i,e),function(e,n,t){var o=n[0],r=n[1],i=n[2],a=n[3],s=n[4],u=n[5],c=n[6],l=n[7],f=n[8],d=n[9],p=n[10],v=n[11],g=n[12],m=n[13],y=n[14],h=n[15],x=t[0],b=t[1],P=t[2],w=t[3];e[0]=x*o+b*s+P*f+w*g,e[1]=x*r+b*u+P*d+w*m,e[2]=x*i+b*c+P*p+w*y,e[3]=x*a+b*l+P*v+w*h,x=t[4],b=t[5],P=t[6],w=t[7],e[4]=x*o+b*s+P*f+w*g,e[5]=x*r+b*u+P*d+w*m,e[6]=x*i+b*c+P*p+w*y,e[7]=x*a+b*l+P*v+w*h,x=t[8],b=t[9],P=t[10],w=t[11],e[8]=x*o+b*s+P*f+w*g,e[9]=x*r+b*u+P*d+w*m,e[10]=x*i+b*c+P*p+w*y,e[11]=x*a+b*l+P*v+w*h,x=t[12],b=t[13],P=t[14],w=t[15],e[12]=x*o+b*s+P*f+w*g,e[13]=x*r+b*u+P*d+w*m,e[14]=x*i+b*c+P*p+w*y,e[15]=x*a+b*l+P*v+w*h}(i,o,i),d=a.createBuffer({size:4*r*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX,mappedAtCreation:!0}),p=a.createBuffer({size:4*r*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX,mappedAtCreation:!1}),v=a.createBuffer({size:4*r*4,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!1}),function(e){for(let n=0;n<r;n++){let t=2*Math.PI*Math.random(),o=Math.acos(2*Math.random()-1);e[4*n+0]=.6*Math.sin(o)*Math.cos(t),e[4*n+1]=.6*Math.sin(o)*Math.sin(t),e[4*n+2]=.6*Math.cos(o),e[4*n+3]=1}}(new Float32Array(d.getMappedRange())),d.unmap(),g=a.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM,mappedAtCreation:!0}),new Float32Array(g.getMappedRange()).set(i),g.unmap();const s=a.createShaderModule({code:h()});c=a.createRenderPipeline({vertex:{module:s,entryPoint:"vs_main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:"float32x4"}],arrayStride:16,stepMode:"instance"}]},fragment:{module:s,entryPoint:"fs_main",targets:[{format:"bgra8unorm",blend:{color:{operation:"add",srcFactor:"one",dstFactor:"one"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one"}}}]},primitive:{frontFace:"cw",cullMode:"none",topology:"triangle-list"}}),u=a.createComputePipeline({compute:{module:s,entryPoint:"cs_main"}})}()}));w(),document.querySelector("#run").addEventListener("click",w),document.querySelector("#stop").addEventListener("click",(function(){u=null,c=null}))})();